# viz.py
from __future__ import annotations

import logging
logger = logging.getLogger(__name__)
from pathlib import Path


def _save_png_and_svg(fig, out_path: Path, *, dpi: int = 300) -> None:
    """Save the same figure into PNG + SVG.

    CIE-friendly: SVG is vector for the manuscript; PNG is quick preview.
    """
    out_path.parent.mkdir(parents=True, exist_ok=True)
    # PNG
    fig.savefig(out_path, dpi=dpi, bbox_inches="tight")
    # SVG (vector)
    fig.savefig(out_path.with_suffix(".svg"), bbox_inches="tight")


def _compute_inner_cut_rect(pp) -> tuple[float, float, float, float]:
    """Infer the *nominal part contour* inside an inflated placement rect.

    In this codebase, packing is performed on an inflated rectangle
    (pp.rect.w/pp.rect.h) while the original part size is stored as (pp.w0, pp.h0).

    For visualization (paper-friendly):
      - outer rectangle  : inflated envelope (clearance / tool-center domain)
      - inner rectangle  : nominal part contour (finished part)

    The inner rectangle is centered inside the inflated one. When rotation is
    enabled, we swap (w0,h0) accordingly.
    """
    r = pp.rect
    w0 = pp.h0 if getattr(pp, "rotated", False) else pp.w0
    h0 = pp.w0 if getattr(pp, "rotated", False) else pp.h0
    dx = max((r.w - w0) * 0.5, 0.0)
    dy = max((r.h - h0) * 0.5, 0.0)
    return (r.x + dx, r.y + dy, w0, h0)


def _safe_import_matplotlib():
    try:
        import matplotlib.pyplot as plt
        from matplotlib.patches import Rectangle
        return plt, Rectangle
    except Exception as e:
        logger.warning("[PLOT] skip (matplotlib not available): %s", e)
        return None, None


def plot_board_layout(
    board,
    out_path: Path,
    title: str,
    *,
    trim: float = 0.0,
    show_clearance: bool = True,
    show_ids: bool = False,
) -> None:
    """Save one board layout figure.

    - Draw board boundary
    - Optionally draw usable area boundary (trim)
    - Draw inflated rectangles (clearance/tool envelope) and inner cut rectangles
    """
    plt, Rectangle = _safe_import_matplotlib()
    if plt is None:
        return

    fig = plt.figure()
    ax = fig.add_subplot(111)
    ax.set_title(title)
    ax.set_aspect("equal", adjustable="box")
    ax.set_xlim(0, board.W)
    ax.set_ylim(0, board.H)

    # board boundary
    ax.add_patch(Rectangle((0, 0), board.W, board.H, fill=False, linewidth=1.2))

    # usable boundary (after trim)
    if trim and trim > 0 and board.W > 2 * trim and board.H > 2 * trim:
        ax.add_patch(Rectangle(
            (trim, trim),
            board.W - 2 * trim, board.H - 2 * trim,
            fill=False, linestyle="--", linewidth=1.0
        ))

    for pp in board.placed:
        r = pp.rect
        # 1) outer (inflated envelope)
        if show_clearance:
            # inflated envelope (clearance domain)
            ax.add_patch(Rectangle((r.x, r.y), r.w, r.h, fill=False, linewidth=0.8, linestyle="--"))

        # 2) inner (nominal cut contour)
        x, y, w, h = _compute_inner_cut_rect(pp)
        # nominal cut contour
        ax.add_patch(Rectangle((x, y), w, h, fill=False, linewidth=1.8))

        if show_ids:
            ax.text(x + w * 0.5, y + h * 0.5, str(pp.uid), ha="center", va="center", fontsize=6)

    _save_png_and_svg(fig, out_path, dpi=300)
    plt.close(fig)


def plot_board_toolpath(
    board,
    out_path: Path,
    title: str,
    *,
    share_mode: str,
    tab_enable: bool = False,
    tab_per_part: int = 0,
    tab_len: float = 0.0,
    tab_corner_clear: float = 0.0,
    line_snap_eps: float = 0.0,
    min_shared_len: float = 0.0,
    nd_coord: int = 6,
    trim: float = 0.0,
) -> None:
    """Save a simplified toolpath figure.

    We visualize the cutting segments generated by `routing.build_segments_from_board`.
    This is a geometry-level plot (paper-friendly) that highlights shared segments.
    """
    plt, Rectangle = _safe_import_matplotlib()
    if plt is None:
        return

    from .routing import build_segments_from_board

    segs, _, _ = build_segments_from_board(
        board,
        share_mode=share_mode,
        tab_enable=tab_enable,
        tab_per_part=tab_per_part,
        tab_len=tab_len,
        tab_corner_clear=tab_corner_clear,
        line_snap_eps=line_snap_eps,
        min_shared_len=min_shared_len,
        nd=nd_coord,
    )

    fig = plt.figure()
    ax = fig.add_subplot(111)
    ax.set_title(title)
    ax.set_aspect("equal", adjustable="box")
    ax.set_xlim(0, board.W)
    ax.set_ylim(0, board.H)
    ax.add_patch(Rectangle((0, 0), board.W, board.H, fill=False, linewidth=1.2))
    if trim and trim > 0 and board.W > 2 * trim and board.H > 2 * trim:
        ax.add_patch(Rectangle(
            (trim, trim),
            board.W - 2 * trim, board.H - 2 * trim,
            fill=False, linestyle="--", linewidth=1.0
        ))

    # draw segments: shared segments thicker (and colored) for visual emphasis
    for s in segs:
        (x1, y1), (x2, y2) = s.a, s.b
        lw = 2.4 if s.shared else 1.0
        color = "red" if s.shared else "black"
        ax.plot([x1, x2], [y1, y2], linewidth=lw, color=color)

    _save_png_and_svg(fig, out_path, dpi=300)
    plt.close(fig)

def plot_one_seed_outputs(
    boards,
    boards_rows,
    out_dir: Path,
    title: str,
    *,
    max_boards: int = 6,
    trim: float = 0.0,
    share_mode: str = "none",
    plot_toolpath: bool = True,
    show_ids: bool = False,
    # toolpath-related knobs (keep consistent with metrics)
    tab_enable: bool = False,
    tab_per_part: int = 0,
    tab_len: float = 0.0,
    tab_corner_clear: float = 0.0,
    line_snap_eps: float = 0.0,
    min_shared_len: float = 0.0,
    nd_coord: int = 6,
) -> None:
    """Plot outputs for the first seed (paper-friendly).

    Generates:
      - board_XXX_layout.png : layout with (outer inflated) + (inner cut) rectangles
      - board_XXX_toolpath.png : cutting segments (shared edges highlighted)
      - boards_metrics_preview.png : textual preview of per-board metrics
    """

    out_dir.mkdir(parents=True, exist_ok=True)

    for b in boards[:max_boards]:
        plot_board_layout(
            b,
            out_dir / f"board_{b.bid:03d}_layout.png",
            title=f"{title} | board={b.bid} layout",
            trim=trim,
            show_clearance=True,
            show_ids=show_ids,
        )

        if plot_toolpath:
            plot_board_toolpath(
                b,
                out_dir / f"board_{b.bid:03d}_toolpath.png",
                title=f"{title} | board={b.bid} toolpath",
                share_mode=share_mode,
                tab_enable=tab_enable,
                tab_per_part=tab_per_part,
                tab_len=tab_len,
                tab_corner_clear=tab_corner_clear,
                line_snap_eps=line_snap_eps,
                min_shared_len=min_shared_len,
                nd_coord=nd_coord,
                trim=trim,
            )

    # 画每块板的 metrics 文字图（快速检查）
    plt, _Rectangle = _safe_import_matplotlib()
    if plt is None:
        return

    fig = plt.figure()
    ax = fig.add_subplot(111)
    ax.axis("off")
    lines = [title, ""]
    for row in boards_rows:
        lines.append(
            f"board={int(row['board']):03d} n={int(row['n_parts'])} "
            f"U={row['U']:.4f} L_shared={row['L_shared']:.1f} "
            f"N_lift={int(row['N_lift'])} L_air={row['L_air']:.1f} "
            f"L_cut={row['L_cut']:.1f} T={row['T_est']:.2f}"
        )
    ax.text(0.01, 0.99, "\n".join(lines), va="top", ha="left", fontsize=9)
    _save_png_and_svg(fig, out_dir / "boards_metrics_preview.png", dpi=300)
    plt.close(fig)
